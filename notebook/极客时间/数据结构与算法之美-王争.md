# 总览图

![img](https://static001.geekbang.org/resource/image/91/a7/913e0ababe43a2d57267df5c5f0832a7.jpg)

# Lessons 1 时间复杂度与空间复杂度

##### 例1: 求 1 ~ n 的累加之和, 代码如下:

```java
1 int cal(int n) {
2    int sum = 0;
3    int i = 1;
4    for (; i <= n; ++i) {
5        sum = sum + i;
6    }
7    return sum;
8 }
```

假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？

第2,3行执行了变量的初始化赋值. 占用`2*unit_time`;

第4,5行都运行了n遍, 占用 `2*n*unit_time`

总计执行时间为: `(2n+2)unit_time`

##### 例2:

```java
1 int cal(int n) {
2   int sum = 0;
3   int i = 1;
4   int j = 1;
5   for (; i <= n; ++i) {
6     j = 1;
7     for (; j <= n; ++j) {
8       sum = sum +  i * j;
9     }
10   }
11 }
```

第2,3,4行, 占用 `3*unit_time`

第5,6行, 占用`2*n*unit_time`

第7,8行, 占用`2*n*n*unit_time`

总计执行时间占用: (3+2n+2n<sup>2</sup> )unit_time

## 结论

所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。

## 大O时间复杂度表达式

T(n) = O( f(n) )

```txt
大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。
```

- T(n)表示代码执行的时间
- n表示数据规模的大小
- f(n)表示每行代码执行的次数总和
- T(n) 与 f(n)成正比

如上,例1: T(n) = O(2n + 2); 例2: T(n) = O(2n<sup>2</sup> + 2n + 3)

## 时间复杂度分析

1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 常见的时间复杂度

<img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt="img" style="zoom:50%;" />

上图时间复杂度,可分为2类:

- 多项式量级
- 非多项式量级, 上图只有2个, O(2<sup>n</sup>) 和 O(n!)
  - 时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。
  - 非多项式量级的算法是非常低效的算法, 随着n的增加, 执行时间会急剧增加

####  常见的多项式量级
##### 1. O(1)时间复杂度

O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)

如下图:

```java
 int i = 8;
 int j = 6;
 int sum = i + j;
```

##### 2. O(logn)、O(nlogn)

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度.例如下图:

```java
1 i=1;
2 while (i <= n)  {
3   i = i * 2;
4 }
```

执行最多次的代码是第3行.

从代码中看出:

1. i从1开始, 每循环1次,i 自乘2.
2. 当 第x次时, i = 2<sup>x</sup>. 假设这个时候刚好到达临界点, 也就是i = n. 下次循环就不执行了
3. 那么2<sup>x</sup> = n, 从而得出x = log<sub>2</sub> n.
4. 该代码的时间复杂度就是O(log<sub>2</sub> n)

实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？

我们知道，对数之间是可以互相转换的，log<sub>3</sub>n 就等于 log<sub>3</sub>2 * log<sub>2</sub>n，所以 O(log<sub>3</sub>n) = O(C * log<sub>2</sub>n)，其中 C=log<sub>3</sub>2 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。

##### 3. O(m+n)、O(m*n)

代码的复杂度由两个数据的规模来决定, m和n

## 空间复杂度分析

- 定义: 空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

例如:

```java
1 void print(int n) {
2  int i = 0;
3  int[] a = new int[n];
4  for (i; i <n; ++i) {
5    a[i] = i * i;
6  }
7
8  for (i = n-1; i >= 0; --i) {
9    print out a[i]
10  }
11 }
```

第3行申请了一个数据空间大小为n的数组. 所以上面代码的空间复杂度为 O(n)

## 浅析 最好/最坏/平均/均摊时间复杂度

1. 最好时间复杂度 (best case time complexity)
2. 最坏时间复杂度 (worst case time complexity)
3. 平均时间复杂度 (average case time complexity)
4. 均摊时间复杂度 (amortized case time complexity)

```java
1 // n表示数组array的长度
2 int find(int[] array, int n, int x) {
3  int i = 0;
4  int pos = -1;
5  for (; i < n; ++i) {
6    if (array[i] == x) pos = i;
7  }
8  return pos;
9}
```

上例: 总体时间复杂度为O(n)

优化后代码如下:

```java

1 // n表示数组array的长度
2 int find(int[] array, int n, int x) {
3   int i = 0;
4   int pos = -1;
5   for (; i < n; ++i) {
6     if (array[i] == x) {
7        pos = i;
8        break;
9     }
10   }
11   return pos;
12 }
```

优化后, 时间复杂度 < O(n), 完全取决于数组和x能够匹配到的数据的索引大小. 最好是O(1), 最坏是O(n), 平均是O(n/2)

### 什么时候要用最好/最坏/平均时间复杂度来衡量代码?

只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

### 均摊时间复杂度 - 摊还分析(平摊分析)

**例1**

```java
1 // array表示一个长度为n的数组
2 // 代码中的array.length就等于n
3 int[] array = new int[n];
4 int count = 0;
5 
6 void insert(int val) {
7    if (count == array.length) {
8       int sum = 0;
9       for (int i = 0; i < array.length; ++i) {
10          sum = sum + array[i];
11       }
12       array[0] = sum;
13       count = 1;
14    }
15
16    array[count] = val;
17    ++count;
18 }
```

1. 均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。
2. 对一个数据结构进行一组连续操作中，***大部分情况***下时间复杂度都很低，只有***个别情况***下时间复杂度比较高，而且这些操作之间存在***前后连贯***的***时序关系***，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，***平摊到***其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度
3. 尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，均摊时间复杂度就是一种特殊的平均时间复杂度，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。

## Lessons 1 总结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。

```java

// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```

1. 数组长度为n, 一个元素插入有n+1种情况: n个O(1), 1个情况找不到, O(n)
2. 最好时间复杂度是O(1)
3. 最坏时间复杂度是O(n)
4. 均摊时间复杂度是(n*1+n)/(n+1) = O(1)

# Lessons 2 数组 Array

## 数组的概念

1. 数组是什么?

- 一种***线性表***数据结构, 使用一组***连续的内存空间***来存储具有***相同类型***的数据.
  - 线性表, Linear List, 顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。
  - 连续的内存空间, 保证能够通过连续的索引,找到对应内存空间的数据
  - 相同类型, 保证每个元素在内存空间中占用的字节数大小一样

2. 数组如何实现***随机访问***?

   <img src="https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg" alt="img" style="zoom:50%;" />

3. 为什么数组的索引是从0开始?

## 数组的时间复杂度分析

| 数组的操作           | 时间复杂度 |
| -------------------- | ---------- |
| 按下标查询(随机访问) | O(1)       |
| 按元素值判断后查询   | O(n)       |
| 删除                 | O(n)       |
| 插入                 | O(n)       |

# Lesson 3 链表 Linked

## 链表的概念

链表Linked List,

## 链表的应用场景

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。

常见的策略有三种:

- 先进先出策略 FIFO（First In，First Out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

其中, LRU缓存淘汰算法, 就适合使用链表来实现

### 如何使用链表实现LRU缓存淘汰算法



## 链表的种类

1. 单链表
2. 双向链表
3. 循环链表
4. 双向循环链表

# Lesson 4 栈 Stack

## 栈的概念

先进后出, 后进先出, 是一种操作受限的线性表

##  API

1. 入栈(或者叫 压栈), push()
2. 出栈(或者叫 弹栈), pop()

## 栈的具体实现方式

1. 使用数组实现栈, 叫做`顺序栈`
2. 使用链表实现栈, 叫做`链式栈`

### 实现的注意点

1. 定义一个指针,head, 指向栈顶, 叫做栈顶指针

## 栈的应用(算法题)

1. 使用栈,完成浏览器的前进和后退功能
2. 使用栈,完成四则运算表达式功能
3. 使用栈,完成左右括号的匹配功能

# Lesson 5 队列 Queue

## 队列的概念

先进先出, 后进后出, 与`栈`的特性刚好相反

## 队列API

1. 入队, enqueue(), 将一个元素放入队列的**尾部**
2. 出队, dequeue(), 从队列的**头部**移除一个元素

## 队列的具体实现方式

1. 使用数组,实现队列, 叫做`顺序队列`
2. 使用链表,实现队列, 叫做`链式队列`

### 实现的注意点:

1. 定义2个指针, 一个head指向队列的头部; 一个tail指向队列的尾部;
2. 循环队列需要特别注意队列`空`和`满`的情况条件判断.
   1. 队列`空`, head == tail
   2. 队列`满`, (tail + 1)%n = head, 为什么是这样, 请仔细研究.
3. 阻塞队列, 怎么加锁 才能实现比较好的性能?
4. 并发队列, 怎么才能实现线程安全的高性能?

## 队列的应用

常见的队列如下:

1. 循环队列
2. 阻塞队列
3. 并发队列

# Lesson 6 递归 Recursion

## 递归的概念

一个大问题, 可以拆分成多个小问题. 且大问题和拆分后的小问题的解决逻辑完全一样.

就这样,小问题在拆分, 最终演变解决一个个小问题

## 递归需要满足的3个条件

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

## 递归的风险

1. 递归代码要警惕堆栈溢出 (递归次数过多, 深度太深,导致创建了很多变量, 从而导致JVM栈溢出)
2. 递归代码要警惕重复计算

## 怎么将递归代码改写为非递归代码？

所有的递归代码都可以改为这种迭代循环的非递归写法, 但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

## 递归的总结和思考

第一，如果递归很深，可能会有堆栈溢出的问题。

第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。

第一个问题，我前面已经解答过了，可以用限制递归深度来解决。

第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。如何来检测环的存在呢？这个我暂时不细说，你可以自己思考下，后面的章节我们还会讲。

# Lesson 7 排序 Sort

## 常见的排序算法

1. 冒泡排序
2. 插入排序
3. 选择排序
4. 归并排序
5. 快速排序
6. 计数排序
7. 基数排序
8. 桶排序

<img src="https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg" alt="img" style="zoom:50%;" />

### 有序度与逆序度

#### 有序度

有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：

```markdown
有序元素对：a[i] <= a[j], 如果i < j。
```

例如:

<img src="https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg" alt="img" style="zoom:50%;" />

### 逆序度

逆序度的定义正好跟有序度相反（默认从小到大为有序）

```markdown
逆序元素对：a[i] > a[j], 如果i < j。
```

### 原地排序算法与稳定排序算法的概念

1. 原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。
2. 稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

### 7.1 冒泡排序

#### 冒泡排序的概念描述

冒泡排序只会操作相邻的两个数据。

每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。

如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

### 7.2 插入排序 (Insertion Sort)

#### 插入排序的概念

1. 将数据分为两个区间:已排序空间和未排序空间
2. 每次从未排序空间的头部拿一个元素,迭代已排序空间,判断该元素放入已排序空间的哪个位置,从而保证已排序空间的有序性

#### 插入排序过程中的2种操作

1. 元素的比较
2. 元素的移动

#### 插入排序分析

1. 插入排序是原地排序算法
2. 插入排序是稳定的排序算法
3. 插入排序的时间复杂度是O(n<sup>2</sup>)

### 7.3 选择排序 (Selection Sort)

### 7.4 归并排序(Merge Sort)



### 7.4 快速排序(Quick Sort)



## 思考题

1. 插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？
2. 

